###scRNA-seq_analysis_Seurat_SingleR###

# Read part of the matrix file from CellRanger
Data <- read.table("matrix.csv")

# Create SeuratObject
data <- CreateSeuratObject(counts = Data)

# Calculate mitochondrial percentage
data[["percent.mt"]] <- PercentageFeatureSet(data, features = mt_genes)

# Data normalization
data <- NormalizeData(data, normalization.method = method)

# Analyze variable genes
data <- FindVariableFeatures(data, selection.method = method, nfeatures = feature)

# Integration across multiple samples
Rumen.anchors <- FindIntegrationAnchors(object.list = list, dims = 1:pca)
Rumen.integrated <- IntegrateData(anchorset = Rumen.anchors, dims = 1:pca)

# Dimensionality reduction
Rumen.integrated <- ScaleData(Rumen.integrated)
Rumen.integrated <- RunPCA(Rumen.integrated, npcs = pca)
Rumen.integrated <- RunUMAP(Rumen.integrated, dims = 1:pca)
Rumen.integrated <- RunTSNE(Rumen.integrated, dims = 1:pca)

# Plot UMAP
umap <- DimPlot(Rumen.integrated, reduction = "umap")

# Plot t-SNE
tsne <- DimPlot(Rumen.integrated, reduction = "tsne")

# Clustering
Rumen.integrated <- FindNeighbors(Rumen.integrated, dims = 1:pca)
Rumen.integrated <- FindClusters(Rumen.integrated, resolution = resolutions)

# Save as rds
saveRDS(Rumen.integrated, "Rumen_integrated.rds")

# Differential expression
Rumen.integrated.markers <- FindAllMarkers(Rumen.integrated)

# Plot heatmap
DoHeatmap(Rumen.integrated, features = feature)

# Plot dot plot
DotPlot(Rumen.integrated, features = feature)

# Read clustering results
ctrl <- readRDS("seurat.rds")

# SingleR annotation
test <- as.SingleCellExperiment(ctrl)
Anno <- SingleR(test = test, ref = BL, method = method)

# Plot UMAP
test@meta.data$labels <- Anno$labels
DimPlot(test, reduction = "umap")

# Plot t-SNE
DimPlot(test, reduction = "tsne")

# Plot heatmap
DoHeatmap(test, features = feature)

# Plot dot plot
DotPlot(test, features = feature)

# Use CellCycleScoring function to calculate cell cycle scores
marrow <- CellCycleScoring(marrow, s.features = s.genes, g2m.features = g2m.genes, set.ident = TRUE)


### Monocle2_analysis ###

# Read rds data
data <- readRDS("infile.rds")

# Build S4 object
HSMM <- newCellDataSet(count, phenoData = pd, featureData = fd)

# Estimate size factors and dispersions
HSMM <- estimateSizeFactors(HSMM)
HSMM <- estimateDispersions(HSMM)

# Filter low-quality genes
HSMM <- detectGenes(HSMM, min_expr = mins)

# Select genes
diff_test_res <- differentialGeneTest(HSMM[expressed_genes,], fullModelFormulaStr = "~ Clusters")
HSMM <- setOrderingFilter(HSMM, ordering_gene)

# Dimensionality reduction
HSMM <- reduceDimension(HSMM, max_components = max_components, method = method)
HSMM <- orderCells(HSMM)

# Visualization
plot_cell_trajectory(HSMM, color_by = "Cluster") 
plot_cell_trajectory(HSMM, color_by = "Sample") 
plot_cell_trajectory(HSMM, color_by = "Pseudotime") 


###RNA_velocity_analysis ###

# Create a loom file
velocyto run10x -m $rmsk_gtf $cellranger_outDir $cellranger_gtf 

# Import packages
import anndata
import scvelo as scv

# Read the file
adata = anndata.read_loom(loom)

# Prepare the data
scv.settings.verbosity = 3  # show errors(0), warnings(1), info(2), hints(3)
scv.settings.presenter_view = True  # set max width size for presenter view
scv.settings.set_figure_params('scvelo')  # for beautified visualization
adata = scv.datasets.pancreas()
scv.pp.filter_and_normalize(adata, min_shared_counts=20, n_top_genes=2000)
scv.pp.moments(adata, n_pcs=30, n_neighbors=30)

# Build dynamical model
scv.tl.recover_dynamics(adata)
scv.tl.velocity(adata, mode='dynamical')
scv.tl.velocity_graph(adata)

# Visualization
scv.pl.velocity_embedding_stream(adata, basis='umap')
top_genes = adata.var['fit_likelihood'].sort_values(ascending=False).index[:300]
scv.pl.heatmap(adata, var_names=top_genes, sortby='latent_time', col_color='clusters', n_convolve=100)
top_genes = adata.var['fit_likelihood'].sort_values(ascending=False).index
scv.pl.scatter(adata, basis=top_genes[:15], ncols=5, frameon=False)



###TCR_scRNA-seq analysis###

library(Seurat)
# Load example scRNA-seq data
seurat <- get(load("seurat.rds"))
# View cell dimensionality reduction clustering information
DimPlot(seurat, label = T) + NoLegend()

# Integrated analysis
seurat <- combineExpression(combined, seurat, 
                            cloneCall="gene", 
                            groupBy = "sample", 
                            proportion = FALSE, 
                            cloneTypes=c(Single=1, Small=5, Medium=20, Large=100, Hyperexpanded=500))

# View distribution based on clonotype type

slot(seurat, "meta.data")$cloneType <- factor(slot(seurat, "meta.data")$cloneType, 
                                              levels = c("Hyperexpanded (100 < X <= 500)", 
                                                         "Large (20 < X <= 100)", 
                                                         "Medium (5 < X <= 20)", 
                                                         "Small (1 < X <= 5)", 
                                                         "Single (0 < X <= 1)", NA))
DimPlot(seurat, group.by = "cloneType") +
  scale_color_manual(values = colorblind_vector(5), na.value="grey")

# Show clones of specific sequences
seurat <- highlightClonotypes(seurat, cloneCall= "aa", sequence = c("CAVNGGSQGNLIF_CSAEREDTDTQYF", "NA_CATSATLRVVAEKLFF"))
DimPlot(seurat, group.by = "highlight")

# Show cluster or other variables in seurat object metadata
occupiedscRepertoire(seurat, x.axis = "cluster")

# Show clonotypes that span multiple categories

alluvialClonotypes(seurat, cloneCall = "gene", 
                   y.axes = c("Patient", "cluster", "Type"), 
                   color = "TRAV12-2.TRAJ42.TRAC_TRBV20-1.TRBJ2-3.TRBD2.TRBC2") + 
  scale_fill_manual(values = c("grey", colorblind_vector(1)))

# Sankey diagram showing relationships between clonotype across different patient-cluster-type 

alluvialClonotypes(seurat, cloneCall = "gene", 
                   y.axes = c("Patient", "cluster", "Type"), 
                   color = "cluster") 


### Visualization_of_scTCR-seq###

# Convert fastq to matrix: cellranger vdj --id=S2-10XTCR --reference=refdata-gex-GRCh38-2020-A --fastqs= --chain=TR --sample=

library(venn)
library(Seurat)
library(scRepertoire)
library(tidyverse)
library(patchwork)
library(pheatmap)
library(VennDiagram)

S1 <- read.csv(".../Sample1/outs/filtered_contig_annotations.csv")
S2 <- read.csv(".../Sample2/outs/filtered_contig_annotations.csv")
S3 <- read.csv(".../Sample3/outs/filtered_contig_annotations.csv")
S4 <- read.csv(".../Sample4/outs/filtered_contig_annotations.csv")
...

contig_list <- list(S1,S2,S3,S4,...)

# Combine VDJ overlapping groups and construct TCR clones
combined <- combineTCR(contig_list, 
                       samples = c("A", "B", "C", "D", ... ), 
                       ID = c("A", "B", "C", "D", ... ), 
                       cells ="T-AB")

# Plot quality graphs
quantContig(combined, cloneCall="gene+nt", scale = TRUE)
abundanceContig(combined, cloneCall = "gene", scale = FALSE)
lengthContig(combined, cloneCall="aa", chains = "combined") 
lengthContig(combined, cloneCall="nt", chains = "TRA") 

# Separate specific clone sequences
compareClonotypes(combined, numbers = 10, 
                  samples = c("A", "B", "C", "D", ...), 
                  cloneCall="aa", graph = "alluvial")

# Visualize TCR or BCR genes

vizVgenes(combined, TCR="TCR1", facet.x = "sample", facet.y = "ID")

# Clonal Space Homeostasis
clonalHomeostasis(combined, cloneCall = "gene")
clonalHomeostasis(combined, cloneCall = "aa")

# Clonal Proportion
clonalProportion(combined, cloneCall = "gene") 
clonalProportion(combined, cloneCall = "nt") 

# Overlap Analysis
clonalOverlap(combined, cloneCall = "gene+nt", method = "morisita")


###scRNA-seq_and_scATAC-seq_analysis###

library(patchwork)
library(Signac)
library(Seurat)
library(ggplot2)
library(hdf5r)
library(spatstat.geom)
library(biovizBase)

# Integrating with scRNA-seq data

# Load Seurat object for scRNA-seq
pbmc_rna <- readRDS("scRNAseq.rds")

# Load Seurat object for scATAC-seq
pbmc <- readRDS("scATACseq.rds")

# Classical association algorithm (CCA) originally used to correct batch effects, here used to integrate RNA (reference) and ATAC (query) data, finding anchors between RNA and ATAC
transfer.anchors <- FindTransferAnchors(  
  reference = pbmc_rna,
  query = pbmc,
  reduction = 'cca')

# Predicted cell labels
predicted.labels <- TransferData(          
  anchorset = transfer.anchors,
  refdata = pbmc_rna$celltype,
  weight.reduction = pbmc[['lsi']],
  dims = 2:30
)

pbmc <- AddMetaData(object = pbmc, metadata = predicted.labels)  # Add predicted cell labels to pbmc's meta.data

## Visualize both types of data
plot1 <- DimPlot(object = pbmc_rna, group.by = 'celltype', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scRNA-seq')
plot2 <- DimPlot(object = pbmc, group.by = 'predicted.id', label = TRUE, repel = TRUE) + NoLegend() + ggtitle('scATAC-seq')
plot1 + plot2

# Find differentially accessible peaks between clusters
DefaultAssay(pbmc) <- 'peaks'  

da_peaks <- FindAllMarkers(
  object = pbmc,
  latent.vars = 'peak_region_fragments'
)

# Plot genomic regions
CoveragePlot(
  object = pbmc,
  region = rownames(da_peaks)[1],
  extend.upstream = 40000,
  extend.downstream = 20000
)


###scATAC-seq_annotation###


library(patchwork)
library(Signac)
library(Seurat)
library(ggplot2)
library(hdf5r)
library(spatstat.geom)
library(biovizBase)

setwd("path")  # Set working directory

# Read CSV metadata file
metadata <- read.csv(
  file = "path/A_singlecell.csv",
  header = TRUE,
  row.names = 1
) 

# Read Peak/Cell matrix
counts <- Read10X_h5(filename = "path/A_filtered_peak_bc_matrix.h5")

# Create ChromatinAssay
chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = 'hg19',
  fragments = 'path/A_fragments.tsv.gz',
  min.cells = 10,
  min.features = 200
)

# Annotation
mm10 <- readRDS("mm10.RDS")
annotations <- readRDS("annotations_mm10.RDS")
chrom_assay <- CreateChromatinAssay(
  counts = counts,
  sep = c(":", "-"),
  genome = mm10,
  fragments = fragment,
  min.cells = 10,  # Include features detected in at least this many cells
  min.features = 1000  # Include cells where at least this many features are detected
)

# Create Seurat object with ChromatinAssay
pbmc <- CreateSeuratObject(
  counts = chrom_assay,
  assay = "peaks",
  meta.data = metadata
)

# Add annotation
Annotation(pbmc) <- annotations

# Compute nucleosome signal score per cell
pbmc <- NucleosomeSignal(object = pbmc)
pbmc$nucleosome_group <- ifelse(pbmc$nucleosome_signal > 4, 'NS > 4', 'NS < 4')
FragmentHistogram(object = pbmc, group.by = 'nucleosome_group')

# Compute Transcriptional start site (TSS) enrichment score
pbmc <- TSSEnrichment(object = pbmc, fast = FALSE)

# Add percentage of reads in peaks and blacklist ratio to meta data
pbmc$pct_reads_in_peaks <- pbmc$peak_region_fragments / pbmc$passed_filters * 100
pbmc$blacklist_ratio <- pbmc$blacklist_region_fragments / pbmc$peak_region_fragments

# Plot violin plots for the above five metrics
VlnPlot(
  object = pbmc,
  features = c('pct_reads_in_peaks', 'peak_region_fragments', 'TSS.enrichment', 'blacklist_ratio', 'nucleosome_signal'),
  pt.size = 0.1,
  ncol = 5
)

# Filter
pbmc <- subset(
  x = pbmc,
  subset = peak_region_fragments > 1000 &
    peak_region_fragments < 50000 &
    pct_reads_in_peaks > 10 &
    blacklist_ratio < 0.05 &
    nucleosome_signal < 4 &
    TSS.enrichment > 2
)

# Dimension reduction
pbmc <- RunTFIDF(pbmc)  # Normalization
pbmc <- FindTopFeatures(pbmc, min.cutoff = 'q0')  # Feature selection
pbmc <- RunSVD(pbmc)  # Dimension reduction

# Reduce dimensionality using RunUMAP()
pbmc <- RunUMAP(object = pbmc, reduction = 'lsi', dims = 2:30)
# Calculate distances between samples based on the reduced data using FindNeighbors()
pbmc <- FindNeighbors(object = pbmc, reduction = 'lsi', dims = 2:30)
# Cluster the adjacency graph using FindClusters()
pbmc <- FindClusters(object = pbmc, verbose = FALSE, algorithm = 3)
# Visualize clustering results using DimPlot()
DimPlot(object = pbmc, label = TRUE) + NoLegend()

# Create gene activity expression matrix
gene.activities <- GeneActivity(pbmc) 

# Add the activity matrix to the pbmc object
pbmc[['RNA']] <- CreateAssayObject(counts = gene.activities)

# Normalize data
pbmc <- NormalizeData(object = pbmc, assay = 'RNA', normalization.method = 'LogNormalize', scale.factor = median(pbmc$nCount_RNA))

# Set default assay to 'RNA'
DefaultAssay(pbmc) <- 'RNA'

# Visualize marker genes' activity values to interpret ATAC-seq clusters
FeaturePlot(
  object = pbmc,
  features = c('GENE'),
  pt.size = 0.1,
  max.cutoff = 'q95',
  ncol = 3
)



###Cis-regulatory_interaction_analysis###

library(cicero)

cicero_data <- read.table("Count.xls",header = TRUE)
#change data.frame to cds object
input_cds <- make_atac_cds(cicero_data, binarize = TRUE)

# Add some cell meta-data
cell_data <- read.table("cluster.xls",header = TRUE,row.names= 1)
pData(input_cds) <- cbind(pData(input_cds), cell_data[row.names(pData(input_cds)),])
pData(input_cds)$cell <- NULL

#Running Cicero
set.seed(2017)
input_cds <- detectGenes(input_cds)
input_cds <- estimateSizeFactors(input_cds)

#input_cds <- preprocessCDS(input_cds, norm_method = "none")
input_cds <- reduceDimension(input_cds, max_components = 2, num_dim=6,
                      reduction_method = 'tSNE', norm_method = "none")

# access the tSNE coordinates from the input CDS object
tsne_coords <- t(reducedDimA(input_cds))
row.names(tsne_coords) <- row.names(pData(input_cds))
cicero_cds <- make_cicero_cds(input_cds, reduced_coordinates = tsne_coords)

# Cicero co-accessibility scores
data("human.hg19.genome")
sample_genome <- subset(human.hg19.genome, V1 == "chr18")
conns <- run_cicero(cicero_cds, sample_genome) # Takes a few minutes to run
head(conns)

#Visualizing Cicero Connections
data(gene_annotation_sample)
plot_connections(conns, "chr18", 8575097, 8839855, 
                gene_model = gene_annotation_sample, 
                coaccess_cutoff = .25, 
                connection_width = .5, 
                collapseTranscripts = "longest" )

#Comparing Cicero connections to other datasets

chia_conns <-  data.frame(Peak1 = c("chr18_10000_10200", "chr18_10000_10200", 
                                  "chr18_49500_49600"), 
                        Peak2 = c("chr18_10600_10700", "chr18_111700_111800", 
                                  "chr18_10600_10700"))
head(chia_conns)

conns$in_chia <- compare_connections(conns, chia_conns)
head(conns)

# Add a column of 1s called "coaccess"
chia_conns <-  data.frame(Peak1 = c("chr18_10000_10200", "chr18_10000_10200", 
                                  "chr18_49500_49600"), 
                        Peak2 = c("chr18_10600_10700", "chr18_111700_111800", 
                                  "chr18_10600_10700"),
                        coaccess = c(1, 1, 1))
plot_connections(conns, "chr18", 10000, 112367, 
                gene_model = gene_annotation_sample, 
                coaccess_cutoff = 0,
                connection_width = .5,
                comparison_track = chia_conns,
                include_axis_track = F,
                collapseTranscripts = "longest") 

# Single-cell accessibility trajectories
input_cds <- make_atac_cds(cicero_data, binarize = TRUE)

# Add some cell meta-data
data("cell_data")
pData(input_cds) <- cbind(pData(input_cds), cell_data[row.names(pData(input_cds)),])
pData(input_cds)$cell <- NULL

agg_cds <- aggregate_nearby_peaks(input_cds, distance = 10000)
agg_cds <- detectGenes(agg_cds)
agg_cds <- estimateSizeFactors(agg_cds)
agg_cds <- estimateDispersions(agg_cds)

#Choosing sites that define progress
# This takes a few minutes to run
diff_timepoint <- differentialGeneTest(agg_cds,
                    fullModelFormulaStr="~timepoint + num_genes_expressed")

# We chose a very high q-value cutoff because there are so few sites in the sample dataset, in general a q-value cutoff in the range of 0.01 to 0.1 would be appropriate
ordering_sites <- row.names(subset(diff_timepoint, qval < 1))

#Choose sites by dpFeature
plot_pc_variance_explained(agg_cds, return_all = F) #Choose 2 PCs

agg_cds <- reduceDimension(agg_cds,
                            max_components = 2,
                            norm_method = 'log',
                            num_dim = 3,
                            reduction_method = 'tSNE',
                            verbose = T)

agg_cds <- clusterCells(agg_cds, verbose = F)

plot_cell_clusters(agg_cds, color_by = 'as.factor(Cluster)')

clustering_DA_sites <- differentialGeneTest(agg_cds, #Takes a few minutes
                                          fullModelFormulaStr = '~Cluster')

ordering_sites <-
row.names(clustering_DA_sites)[order(clustering_DA_sites$qval)][1:1000]

# Reduce the dimensionality of the data and order cells
agg_cds <- setOrderingFilter(agg_cds, ordering_sites)

agg_cds <- reduceDimension(agg_cds, max_components = 2,
        residualModelFormulaStr="~as.numeric(num_genes_expressed)",
        reduction_method = 'DDRTree')
agg_cds <- orderCells(agg_cds)
plot_cell_trajectory(agg_cds, color_by = "timepoint")

# plot
plot_cell_trajectory(agg_cds, color_by = "State")
agg_cds <- orderCells(agg_cds, root_state = 4)
plot_cell_trajectory(agg_cds, color_by = "Pseudotime")

pData(input_cds)$Pseudotime <- pData(agg_cds)[colnames(input_cds),]$Pseudotime
pData(input_cds)$State <- pData(agg_cds)[colnames(input_cds),]$State

# Differential Accessibility Analysis
input_cds_lin <- input_cds[,row.names(subset(pData(input_cds), State  != 5))]

plot_accessibility_in_pseudotime(input_cds_lin[c("chr18_38156577_38158261", "chr18_48373358_48374180", "chr18_60457956_60459080")])
